
Gator mi deve dare l' amuleto dell' acqua
	devo fare uno state o una window apposta per mostrare l' amuleto per bene in grande ?

liv3 
	map0 all' aperto
	map1 in salita magari su un albero ? nemici ragni e uccelli
	map2 sono sulla cima dell' albero e boss aquila
	

Cheat in titleScreen KonamiCode
	99 lives
	tutti gli amuleti


FUNZIONALITA' DA IMPLEMENTARE: 
	- CHECKPOINT DI SALVATAGGIO

OTTIMIZZAZIONI:
	- SI PUO SPOSTARE L' ENEMYDAMAGE DAI CUSTOM_DATA DELL' EnemyInfo A DELLE COSTANTI

SOUND EFFECT DI 1UP
SOUND EFFECT DI SHIELD
SOUND EFFECT DI EXIT SENZA TOOL


SOSTITUZIONE TILES DI MAPPA:
GetScrollTile mi becca	se ci sono sopra o no, set_bkg_tiles(...) dovrebbe fare la sostituzione
	MONETE   	-> TILE DI BACKGROUND
	CESPUGLIO 	-> RAMO
sul player ho verificato che funziona:
	if (GetScrollTile((THIS->x >> 3) +1, (THIS->y >> 3)) == 32u){
		const unsigned char empty_tile[1] ={0};
		set_bkg_tiles((THIS->x >> 3)+1, (THIS->y >> 3), 1, 1, empty_tile);
		archer_data->coins += 1;
	}
la sostituzione la fa, però se esco e rientro con la videata di scroll la tile vecchia viene ripristinata
in più se è tipo un coin, questo mantiere le sue funzionalità di pickup, cioè
la condizione dell' if è sempre vera anche se a video non vedo più il coin.



RICORDARSI ALLA FINE DI TUTTO DI SOSTITUIRE LE TILE DI
SECRET, ENTRATA BOSS, USCITA BOSS, HIDDEN ITEMS

TITLESCREEN COME DA LOGO CONCORDATO CON KATALIN

EVITARE DI USARE LA PRINT PER MOSTRARE GLI AMULETI
IN CAMBIO METTERE  tile sulla window:
unsigned char face[] = {TILE0, TILE2, TILE1, TILE3};
set_win_tiles(1, 2, 2, 2, face); // solito: (posx, posy, width, height, array di tiles in numeri interi)


C:\GB\ZGBNEW\tools\romusage-main\bin\romusage.exe C:\GB\ZGBNEW\ZGB-template-master\Debug\ARROWS_Debug.noi -g


DISCORD MARKDOWN: ```c ```

SpritePlayer.c

```c

struct Sprite* snake1 = 0;
...

void spawn_enemy(struct Sprite* enem, UINT8 spriteType, UINT16 posx, UINT16 posy){
	if(enem == 0){ 
		enem = SpriteManagerAdd(spriteType, (UINT16) 17u << 3, (UINT16) 39u << 3); 
	}else{ 
		struct EnemyInfo* datae = (struct EnemyInfo*)enem->custom_data; 
		if(datae->hp <= 0){
			enem = SpriteManagerAdd(spriteType, posx, posy);
		}
	}						
}

void Update_StateGame(){
...
if (scroll_target->x == (UINT16) 28u << 3 & scroll_target->y == (INT16) 14u  << 3){
	spawn_enemy(snake1, SpriteRat, (UINT16) 43u << 3, (UINT16) 14u << 3);
}
...
}
```

SpritePlayer.c
```c
if (GetScrollTile((THIS->x >> 3) +1, (THIS->y >> 3)) == 32u){
		const unsigned char empty_tile[1] ={0};
		set_bkg_tiles((THIS->x >> 3)+1, (THIS->y >> 3), 1, 1, empty_tile);
		archer_data->coins += 1;
	}
```

PER LE MONETE! 
#include "..\res\src\tiles.h"
...
set_bkg_tiles(THIS->x, THIS->y, 1, 1, tiles.data->data+3u);


tiles.h
```c
extern struct TilesInfo tiles;
```

TilesInfo.h
```c

struct TilesInfoInternal {
	unsigned char width;
	unsigned char height;
	unsigned char num_frames;
	unsigned char* data; // HERE IT IS !!
	unsigned char* color_data; 
};

struct TilesInfo {
	unsigned char bank;
	struct TilesInfoInternal const* data;
};

```

Now the declaration of the method I want to call:
```c
/** Sets the tiles in the background tile table.
    Starting at position x,y in tiles and writing across for w tiles
    and down for h tiles. Taking the values starting from the pointer
    data.
    @param data		Pointer to an unsigned char. Usually the 
    			first element in an array. // HERE IT IS !!
*/
void
set_bkg_tiles(UINT8 x,
	      UINT8 y,
	      UINT8 w,
	      UINT8 h,
	      unsigned char *tiles) NONBANKED; // HERE IT IS !!
```