alleggerire il background, usare un solo colore.

problemi nelle collision_tiles4 all' accesso ibex da stage fulmini. ho risolto sdoppiando l' array collision_tiles4 in due posizioni diverse. è molto sbagliato ma non so come altro fare. Dovrei chiedere suggerimento sul Discord

Livl 4 Map 0 
	non prende lo spawn dei rat al 14;40
	il ritorno dal secret non è sulla freccia giusta ma sul tile di inizio mappa !s

LIV 0 ZOO -> Wolf -> tool per uscita
LIV 1 SEWER -> Gator -> stone
LIV 2 FOREST -> Eagle  -> tool per uscita
LIV 3 SKY -> Ibex -> thunder
LIV 4 MOUNTAINS -> ??? tool di uscita
LIV 5 GROTTA CON STALATITI E STALAGMITI -> ??? -> water
LIV 6 CASTELLO -> Final Boss lo colpisci con water+elettricità -> fire


devo fare un dialogo apposta per mostrare l' amuleto per bene in grande quando lo prendo

devo fare lo state di inventario, con questa scusa metto le descrizioni e miniature degli amuleti. E' un feticismo che dovrebbe aiutare all' estetica del gioco, senza aggiungere effettivamente valore aggiunto. Così ad es metto 5 campi vuoti per mostrare che è possibile collezionare massimo 5 amuleti

bisogna pensare ad un maggior replay value: potrebbero esserci delle warp zone nelle stanze segrete (così posso usare lo SpriteGate dandogli la vx->fire) 
il cui accesso è possibile solo rompendo un gate di fuoco ? Dato che il fuoco me lo da solo il boss finale ...
ecco: la prima volta che incontro il boss finale, lui non muore, e mi rispedisce allo zoo. Nella secret delle fogne metto sta cosa, così c'è warp che mi porta al VERO ultimo stage,
con di nuovo il boss finale, ma più incazzato.

map3tree ha un uccello che spawna in screen

state di inizio ogni nuovo livello, sarà un tileset magari con una bella immagine a tutto schermo, tanto ho scoperto come fare nuovi stati con tileset dedicato !!!!!!

schermata di scelta livello / mappa !

intro iniziale con poesia su una pergamena di carta !

CONTROLLO di tutti i suggerimenti/dialoghi
RIPRISTINARE IL SISTEMA DI DIALOGO CON BOSS IN WAIT, è figo.

Cheat in titleScreen KonamiCode
	99 lives
	tutti gli amuleti

per evitare i glitch quando ho troppe frecce in screen, dovrei mettere un contatore in RAM, direi dallo SpritePlayer,
che ogni freccia che lasce fa +1, ad ogni destroy fa -1, e raggiunto un limite massimo non scocca più.

LA MORTE NEL BOSS DEVE FAR RIPARTIRE DAL LIVELLO BOSS, NON DALLA MAPPA

GAMEOVER RESTYLED

SOUND EFFECT DI 1UP
SOUND EFFECT DI SHIELD
SOUND EFFECT DI EXIT SENZA TOOL


SOSTITUZIONE TILES DI MAPPA:
GetScrollTile mi becca	se ci sono sopra o no, set_bkg_tiles(...) dovrebbe fare la sostituzione
	MONETE   	-> TILE DI BACKGROUND
	CESPUGLIO 	-> RAMO
sul player ho verificato che funziona:
	if (GetScrollTile((THIS->x >> 3) +1, (THIS->y >> 3)) == 32u){
		const unsigned char empty_tile[1] ={0};
		set_bkg_tiles((THIS->x >> 3)+1, (THIS->y >> 3), 1, 1, empty_tile);
		archer_data->coins += 1;
	}
la sostituzione la fa, però se esco e rientro con la videata di scroll la tile vecchia viene ripristinata
in più se è tipo un coin, questo mantiere le sue funzionalità di pickup, cioè
la condizione dell' if è sempre vera anche se a video non vedo più il coin.

DEATHMATCH CON LINK

RICORDARSI ALLA FINE DI TUTTO DI SOSTITUIRE LE TILE DI
SECRET, ENTRATA BOSS, USCITA BOSS, HIDDEN ITEMS

TITLESCREEN COME DA LOGO CONCORDATO CON KATALIN

RESTYLE DEL BORDO sgb A PARTIRE DA COVER E LOGO DI KATALIN. fUNZIONA TUTTO, è NELLA CARTELLA C:\GB\ZGBNEW\tools\border\


POTREI EVITARE DI USARE LA PRINT PER MOSTRARE GLI AMULETI
IN CAMBIO METTERE  tile sulla window:
unsigned char face[] = {TILE0, TILE2, TILE1, TILE3};
set_win_tiles(1, 2, 2, 2, face); // solito: (posx, posy, width, height, array di tiles in numeri interi)
così risparmio qualche posizione sullo spazio per gli sprite.

C:\GB\ZGBNEW\tools\romusage-main\bin\romusage.exe C:\GB\ZGBNEW\ZGB-template-master\Debug\ARROWS_Debug.noi -g


DISCORD MARKDOWN: ```c ```

```c
...
INT8 maxarrows = 0;
...
void Start_SpriteArrow() {
...
	if(maxarrows <= 5){
		maxarrows++;
	}
..}

void Update_SpriteArrow() {
	if(maxarrows>5){
		SpriteManagerRemove(THIS_IDX);
		return;
	}
	...
}
void Destroy_SpriteArrow() {
	maxarrows--;
}

```
